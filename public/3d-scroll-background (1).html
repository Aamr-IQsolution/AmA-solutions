<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>خلفية ثلاثية الأبعاد تفاعلية</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@300;700;900&display=swap');

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --clr-bg: #04040f;
      --clr-accent1: #00f5d4;
      --clr-accent2: #7b2fff;
      --clr-accent3: #ff4b6e;
      --clr-text: #e8e8f0;
    }

    html { scroll-behavior: smooth; }

    body {
      background: var(--clr-bg);
      color: var(--clr-text);
      font-family: 'Cairo', sans-serif;
      overflow-x: hidden;
    }

    /* ── Canvas Fixed Background ── */
    #bg-canvas {
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
    }

    /* ── Scrollable Content ── */
    .page {
      position: relative;
      z-index: 1;
    }

    .section {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 4rem 2rem;
    }

    /* Glass card */
    .card {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      border-radius: 24px;
      padding: 3.5rem 4rem;
      max-width: 680px;
      width: 100%;
      box-shadow: 0 0 80px rgba(123,47,255,0.15), 0 0 0 1px rgba(0,245,212,0.05);
    }

    .badge {
      display: inline-block;
      font-size: 0.72rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--clr-accent1);
      border: 1px solid rgba(0,245,212,0.35);
      border-radius: 999px;
      padding: 0.3rem 1rem;
      margin-bottom: 1.6rem;
    }

    h1 {
      font-size: clamp(2.4rem, 6vw, 4rem);
      font-weight: 900;
      line-height: 1.1;
      margin-bottom: 1.2rem;
      background: linear-gradient(135deg, var(--clr-accent1) 0%, var(--clr-accent2) 60%, var(--clr-accent3) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    h2 {
      font-size: clamp(1.6rem, 4vw, 2.6rem);
      font-weight: 700;
      margin-bottom: 1rem;
      color: var(--clr-text);
    }

    p {
      font-size: 1.05rem;
      line-height: 1.8;
      color: rgba(232,232,240,0.7);
      font-weight: 300;
    }

    .scroll-hint {
      margin-top: 3rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      color: rgba(0,245,212,0.5);
      font-size: 0.75rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      animation: bounce 2s ease-in-out infinite;
    }

    .scroll-hint svg { width: 20px; opacity: 0.6; }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50%       { transform: translateY(8px); }
    }

    /* Progress bar */
    #progress {
      position: fixed;
      top: 0; left: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--clr-accent1), var(--clr-accent2));
      z-index: 100;
      transition: width 0.1s linear;
      box-shadow: 0 0 12px var(--clr-accent1);
    }

    /* Stat chips */
    .stats {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 2rem;
    }

    .stat {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 14px;
      padding: 1.2rem 1.8rem;
      min-width: 130px;
    }

    .stat-num {
      font-size: 2rem;
      font-weight: 900;
      background: linear-gradient(135deg, var(--clr-accent1), var(--clr-accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stat-label {
      font-size: 0.78rem;
      color: rgba(232,232,240,0.5);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    /* Divider */
    .divider {
      width: 60px; height: 2px;
      background: linear-gradient(90deg, var(--clr-accent2), transparent);
      margin: 1.5rem auto;
    }
  </style>
</head>
<body>

<!-- Progress bar -->
<div id="progress"></div>

<!-- Three.js Canvas -->
<canvas id="bg-canvas"></canvas>

<!-- Page Content -->
<div class="page">

  <!-- Section 1 -->
  <section class="section">
    <div class="card">
      <span class="badge">خلفية ثلاثية الأبعاد</span>
      <h1>شكل هندسي تفاعلي</h1>
      <p>مرر الصفحة للأسفل وشاهد كيف يتحول الشكل الثلاثي الأبعاد ويدور باستجابة ناعمة لحركتك</p>
      <div class="scroll-hint">
        <span>تمرير للأسفل</span>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 5v14M5 12l7 7 7-7"/>
        </svg>
      </div>
    </div>
  </section>

  <!-- Section 2 -->
  <section class="section">
    <div class="card">
      <h2>التحول الأول</h2>
      <div class="divider"></div>
      <p>في هذه المرحلة بدأ الشكل يدور حول محوره ويتمدد — لاحظ كيف تتفاعل الأوجه الهندسية مع تمريرك</p>
      <div class="stats">
        <div class="stat">
          <div class="stat-num">60</div>
          <div class="stat-label">إطار/ث</div>
        </div>
        <div class="stat">
          <div class="stat-num">WebGL</div>
          <div class="stat-label">محرك</div>
        </div>
        <div class="stat">
          <div class="stat-num">3D</div>
          <div class="stat-label">بُعد</div>
        </div>
      </div>
    </div>
  </section>

  <!-- Section 3 -->
  <section class="section">
    <div class="card">
      <h2>التحول الثاني</h2>
      <div class="divider"></div>
      <p>الشكل الآن في أقصى دورانه — تتشابك الحواف وتتكثف الإضاءة لإنتاج تأثير بصري آسر لا يُنسى</p>
    </div>
  </section>

  <!-- Section 4 -->
  <section class="section">
    <div class="card">
      <span class="badge">Three.js</span>
      <h2>جاهز للدمج</h2>
      <div class="divider"></div>
      <p>هذا الكود مُحسَّن للأداء ويعمل على جميع المتصفحات الحديثة. يمكنك تغيير الألوان والسرعة والهندسة بسهولة تامة</p>
    </div>
  </section>

</div>

<!-- Three.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// ═══════════════════════════════════════════════════
//  SETUP
// ═══════════════════════════════════════════════════
const canvas   = document.getElementById('bg-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 5);

// ═══════════════════════════════════════════════════
//  GEOMETRY — Icosahedron + wireframe overlay
// ═══════════════════════════════════════════════════
const geoMain = new THREE.IcosahedronGeometry(1.6, 1);

const matMain = new THREE.MeshPhongMaterial({
  color: 0x0a0a1a,
  emissive: 0x100020,
  shininess: 120,
  transparent: true,
  opacity: 0.85,
  side: THREE.DoubleSide,
});

const mesh = new THREE.Mesh(geoMain, matMain);
scene.add(mesh);

// Wireframe shell
const wireGeo = new THREE.IcosahedronGeometry(1.62, 1);
const wireMat = new THREE.MeshBasicMaterial({
  color: 0x00f5d4,
  wireframe: true,
  transparent: true,
  opacity: 0.35,
});
const wire = new THREE.Mesh(wireGeo, wireMat);
scene.add(wire);

// Inner glowing core
const coreGeo = new THREE.IcosahedronGeometry(0.85, 0);
const coreMat = new THREE.MeshBasicMaterial({
  color: 0x7b2fff,
  wireframe: true,
  transparent: true,
  opacity: 0.5,
});
const core = new THREE.Mesh(coreGeo, coreMat);
scene.add(core);

// Outer halo ring
const ringGeo = new THREE.TorusGeometry(2.5, 0.012, 8, 120);
const ringMat = new THREE.MeshBasicMaterial({ color: 0xff4b6e, transparent: true, opacity: 0.4 });
const ring  = new THREE.Mesh(ringGeo, ringMat);
ring.rotation.x = Math.PI / 2.5;
scene.add(ring);

const ring2Geo = new THREE.TorusGeometry(2.9, 0.008, 8, 120);
const ring2Mat = new THREE.MeshBasicMaterial({ color: 0x00f5d4, transparent: true, opacity: 0.2 });
const ring2 = new THREE.Mesh(ring2Geo, ring2Mat);
ring2.rotation.x = Math.PI / 3.5;
ring2.rotation.z = Math.PI / 4;
scene.add(ring2);

// ═══════════════════════════════════════════════════
//  PARTICLE FIELD
// ═══════════════════════════════════════════════════
const particleCount = 600;
const positions = new Float32Array(particleCount * 3);
for (let i = 0; i < particleCount; i++) {
  const theta = Math.random() * Math.PI * 2;
  const phi   = Math.acos(2 * Math.random() - 1);
  const r     = 3.5 + Math.random() * 3;
  positions[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
  positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
  positions[i * 3 + 2] = r * Math.cos(phi);
}
const partGeo = new THREE.BufferGeometry();
partGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const partMat = new THREE.PointsMaterial({
  color: 0x00f5d4, size: 0.022, transparent: true, opacity: 0.7, sizeAttenuation: true
});
const particles = new THREE.Points(partGeo, partMat);
scene.add(particles);

// ═══════════════════════════════════════════════════
//  LIGHTS
// ═══════════════════════════════════════════════════
const ambient = new THREE.AmbientLight(0x0a0a2a, 2);
scene.add(ambient);

const light1 = new THREE.PointLight(0x00f5d4, 4, 12);
light1.position.set(4, 3, 3);
scene.add(light1);

const light2 = new THREE.PointLight(0x7b2fff, 4, 12);
light2.position.set(-4, -2, 3);
scene.add(light2);

const light3 = new THREE.PointLight(0xff4b6e, 2, 10);
light3.position.set(0, 4, -3);
scene.add(light3);

// ═══════════════════════════════════════════════════
//  SCROLL TRACKING
// ═══════════════════════════════════════════════════
let scrollProgress = 0;
const progressBar  = document.getElementById('progress');

window.addEventListener('scroll', () => {
  const total = document.body.scrollHeight - window.innerHeight;
  scrollProgress = total > 0 ? window.scrollY / total : 0;
  progressBar.style.width = (scrollProgress * 100) + '%';
});

// ═══════════════════════════════════════════════════
//  ANIMATION LOOP
// ═══════════════════════════════════════════════════
const clock = new THREE.Clock();

// Smooth scroll interpolation
let smoothScroll = 0;

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  // Ease scroll value
  smoothScroll += (scrollProgress - smoothScroll) * 0.06;
  const s = smoothScroll;

  // ── Main mesh: rotate based on scroll + idle spin
  mesh.rotation.x = s * Math.PI * 1.8 + t * 0.12;
  mesh.rotation.y = s * Math.PI * 2.4 + t * 0.18;

  // Scale pulse
  const pulse = 1 + 0.06 * Math.sin(t * 1.8);
  const scrollScale = 1 + s * 0.35;
  mesh.scale.setScalar(pulse * scrollScale);

  // Wireframe counter-spin
  wire.rotation.x = -s * Math.PI * 1.2 + t * 0.09;
  wire.rotation.y =  s * Math.PI * 1.6 + t * 0.14;
  wire.scale.setScalar(pulse * scrollScale);

  // Core spins fast
  core.rotation.x = t * 0.6 + s * Math.PI * 3;
  core.rotation.y = t * 0.9 + s * Math.PI * 2;
  core.scale.setScalar(1 + 0.15 * Math.sin(t * 2.5));

  // Rings
  ring.rotation.z  = t * 0.25 + s * Math.PI;
  ring.rotation.y  = t * 0.1;
  ring2.rotation.z = -t * 0.18 + s * Math.PI * 1.5;
  ring2.rotation.x = t * 0.08 + s * 1.2;

  // Dynamic ring opacity
  ringMat.opacity  = 0.2 + 0.3 * Math.abs(Math.sin(t * 0.7));
  ring2Mat.opacity = 0.1 + 0.2 * Math.abs(Math.sin(t * 0.5 + 1));

  // Particles rotate slowly
  particles.rotation.y = t * 0.04 + s * Math.PI * 0.6;
  particles.rotation.x = t * 0.02 + s * Math.PI * 0.3;

  // Lights orbit
  light1.position.x = 4 * Math.cos(t * 0.5);
  light1.position.z = 4 * Math.sin(t * 0.5);
  light2.position.x = -4 * Math.cos(t * 0.4 + 1);
  light2.position.z = -4 * Math.sin(t * 0.4 + 1);

  // Wireframe color shift via emissive (hue rotation effect)
  const hue  = (t * 30) % 360;
  const c    = new THREE.Color(`hsl(${hue}, 100%, 60%)`);
  wireMat.color = c;

  // Camera slight drift
  camera.position.x = Math.sin(t * 0.15) * 0.4;
  camera.position.y = Math.cos(t * 0.12) * 0.25 - s * 0.6;
  camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}
animate();

// ═══════════════════════════════════════════════════
//  RESIZE
// ═══════════════════════════════════════════════════
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
